---
title: 'Execute Agent Run'
description: 'Continue execution of an existing run by sending additional messages'
api: 'POST /v1/agents/runs/{run_id}/execute'
---

# Execute Agent Run

The Execute Agent Run endpoint continues execution of an existing run by sending additional messages or commands. This is used for multi-turn conversations with an agent.

## Request

<RequestExample>
```bash cURL
curl -X POST https://api.yourdomain.com/v1/agents/runs/run_abc123def456/execute \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Can you elaborate on that?",
    "stream": false,
    "max_completion_tokens": 500
  }'
```

```javascript Node.js
const axios = require('axios');

const apiKey = 'YOUR_API_KEY';
const runId = 'run_abc123def456';

axios.post(`https://api.yourdomain.com/v1/agents/runs/${runId}/execute`, {
  message: 'Can you elaborate on that?',
  stream: false,
  max_completion_tokens: 500
}, {
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  }
})
.then(response => console.log(response.data))
.catch(error => console.error(error.response.data));
```

```python Python
import requests

api_key = 'YOUR_API_KEY'
run_id = 'run_abc123def456'

headers = {
    'Authorization': f'Bearer {api_key}',
    'Content-Type': 'application/json'
}

data = {
    'message': 'Can you elaborate on that?',
    'stream': False,
    'max_completion_tokens': 500
}

response = requests.post(
    f'https://api.yourdomain.com/v1/agents/runs/{run_id}/execute',
    json=data,
    headers=headers
)

print(response.json())
```
</RequestExample>

### Path Parameters

<ParamField path="run_id" type="string" required>
  The ID of the run to execute.
</ParamField>

### Request Body

<ParamField body="message" type="string">
  A message from the user to send to the agent. Required unless `command` is provided.
</ParamField>

<ParamField body="command" type="object">
  A command to send to the agent. Required unless `message` is provided.
  
  <Expandable title="Command Object Properties">
    <ParamField body="type" type="string" required>
      The type of command to send.
      
      Supported values: `tool_result`, `cancel`, `retry`
    </ParamField>
    
    <ParamField body="data" type="object" required>
      Command-specific data. The structure depends on the command type.
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="stream" type="boolean" default={false}>
  If true, the response will be streamed as a series of server-sent events. If false, the response will be returned as a single JSON object.
</ParamField>

<ParamField body="max_completion_tokens" type="integer">
  The maximum number of tokens to generate in the response. If not provided, the value from the run's configuration will be used.
</ParamField>

## Response

<ResponseExample>
```json Success
{
  "id": "run_abc123def456",
  "object": "agent.run",
  "status": "completed",
  "created_at": 1699564800,
  "completed_at": 1699564830,
  "config": {
    "name": "My Agent",
    "model": "gpt-4",
    "instructions": "You are a helpful assistant...",
    "tools": ["web_search"],
    "parameters": {
      "temperature": 0.7,
      "max_tokens": 1000
    }
  },
  "messages": [
    {
      "id": "msg_001",
      "role": "user",
      "content": "Hello, I need help with...",
      "created_at": 1699564800
    },
    {
      "id": "msg_002",
      "role": "assistant",
      "content": "I'd be happy to help! Here's what I found...",
      "created_at": 1699564815
    },
    {
      "id": "msg_003",
      "role": "user",
      "content": "Can you elaborate on that?",
      "created_at": 1699564825
    },
    {
      "id": "msg_004",
      "role": "assistant",
      "content": "Certainly! Let me provide more details...",
      "created_at": 1699564830
    }
  ],
  "usage": {
    "prompt_tokens": 150,
    "completion_tokens": 75,
    "total_tokens": 225
  }
}
```

```json Error
{
  "error": {
    "type": "not_found",
    "message": "Run not found"
  }
}
```
</ResponseExample>

### Response Fields

<ResponseField name="id" type="string">
  A unique identifier for the run.
</ResponseField>

<ResponseField name="object" type="string">
  The type of object. Always `agent.run` for run objects.
</ResponseField>

<ResponseField name="status" type="string">
  The current status of the run.
  
  Possible values:
  - `queued`: Run created, waiting to start
  - `in_progress`: Currently executing
  - `completed`: Finished successfully
  - `failed`: Execution failed
  - `cancelled`: Manually cancelled
</ResponseField>

<ResponseField name="created_at" type="integer">
  Unix timestamp (in seconds) when the run was created.
</ResponseField>

<ResponseField name="completed_at" type="integer">
  Unix timestamp (in seconds) when the run was completed. Only present if the run is completed.
</ResponseField>

<ResponseField name="config" type="object">
  The agent configuration used for this run.
</ResponseField>

<ResponseField name="messages" type="array">
  An array of message objects representing the conversation history.
  
  <Expandable title="Message Object Properties">
    <ResponseField name="id" type="string">
      A unique identifier for the message.
    </ResponseField>
    
    <ResponseField name="role" type="string">
      The role of the message sender. Either `user` or `assistant`.
    </ResponseField>
    
    <ResponseField name="content" type="string">
      The content of the message.
    </ResponseField>
    
    <ResponseField name="created_at" type="integer">
      Unix timestamp (in seconds) when the message was created.
    </ResponseField>
    
    <ResponseField name="tool_calls" type="array">
      An array of tool call objects. Only present if the message contains tool calls.
      
      <Expandable title="Tool Call Object Properties">
        <ResponseField name="id" type="string">
          A unique identifier for the tool call.
        </ResponseField>
        
        <ResponseField name="tool" type="string">
          The name of the tool being called.
        </ResponseField>
        
        <ResponseField name="parameters" type="object">
          The parameters passed to the tool.
        </ResponseField>
      </Expandable>
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="usage" type="object">
  Token usage statistics for the run.
  
  <Expandable title="Usage Object Properties">
    <ResponseField name="prompt_tokens" type="integer">
      The number of tokens in the prompt.
    </ResponseField>
    
    <ResponseField name="completion_tokens" type="integer">
      The number of tokens in the completion.
    </ResponseField>
    
    <ResponseField name="total_tokens" type="integer">
      The total number of tokens used.
    </ResponseField>
  </Expandable>
</ResponseField>

## Streaming Response

When `stream` is set to `true`, the response will be streamed as a series of server-sent events. Each event will be a JSON object with the following structure:

```json
{
  "type": "message_start",
  "message": {
    "id": "msg_004",
    "role": "assistant",
    "created_at": 1699564830
  }
}
```

```json
{
  "type": "message_delta",
  "delta": {
    "content": "Certainly! "
  }
}
```

```json
{
  "type": "message_delta",
  "delta": {
    "content": "Let me provide "
  }
}
```

```json
{
  "type": "message_delta",
  "delta": {
    "content": "more details..."
  }
}
```

```json
{
  "type": "message_complete",
  "message": {
    "id": "msg_004",
    "role": "assistant",
    "content": "Certainly! Let me provide more details...",
    "created_at": 1699564830
  }
}
```

```json
{
  "type": "run_update",
  "run": {
    "id": "run_abc123def456",
    "status": "completed",
    "usage": {
      "prompt_tokens": 150,
      "completion_tokens": 75,
      "total_tokens": 225
    }
  }
}
```

## Error Codes

<AccordionGroup>
  <Accordion title="400: Bad Request">
    Returned when the request body is malformed or missing required fields.
    
    ```json
    {
      "error": {
        "type": "validation_error",
        "message": "Invalid request body",
        "param": "message"
      }
    }
    ```
  </Accordion>
  
  <Accordion title="401: Unauthorized">
    Returned when the API key is missing or invalid.
    
    ```json
    {
      "error": {
        "type": "authentication_error",
        "message": "Invalid API key provided"
      }
    }
    ```
  </Accordion>
  
  <Accordion title="404: Not Found">
    Returned when the specified run does not exist.
    
    ```json
    {
      "error": {
        "type": "not_found",
        "message": "Run not found"
      }
    }
    ```
  </Accordion>
  
  <Accordion title="409: Conflict">
    Returned when the run is in a state that doesn't allow execution.
    
    ```json
    {
      "error": {
        "type": "conflict",
        "message": "Run is already completed"
      }
    }
    ```
  </Accordion>
  
  <Accordion title="429: Too Many Requests">
    Returned when you've exceeded the rate limit for this endpoint.
    
    ```json
    {
      "error": {
        "type": "rate_limit_exceeded",
        "message": "Rate limit exceeded. Please retry after 2023-11-10T00:01:00Z",
        "retry_after": 45
      }
    }
    ```
  </Accordion>
</AccordionGroup>

## Usage Examples

### Basic Conversation

<CodeGroup>
```javascript
// First, create a run
const createResponse = await fetch('https://api.yourdomain.com/v1/agents/runs', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    config: {
      name: "Customer Support Agent",
      model: "gpt-4",
      instructions: "You are a helpful customer support agent."
    },
    initial_message: "I'm having trouble with my account login."
  })
});

const run = await createResponse.json();
const runId = run.id;

// Then, execute the run to get the assistant's response
const executeResponse = await fetch(`https://api.yourdomain.com/v1/agents/runs/${runId}/execute`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({})
});

const executionResult = await executeResponse.json();
console.log(executionResult.messages[executionResult.messages.length - 1].content);

// Continue the conversation
const followUpResponse = await fetch(`https://api.yourdomain.com/v1/agents/runs/${runId}/execute`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    message: "I tried resetting my password but it's not working."
  })
});

const followUpResult = await followUpResponse.json();
console.log(followUpResult.messages[followUpResult.messages.length - 1].content);
```
</CodeGroup>

### Streaming Response

<CodeGroup>
```javascript
const runId = 'run_abc123def456';

// Set up event source for streaming
const eventSource = new EventSource(
  `https://api.yourdomain.com/v1/agents/runs/${runId}/execute?stream=true`,
  {
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    method: 'POST',
    body: JSON.stringify({
      message: "Tell me more about your services.",
      stream: true
    })
  }
);

let currentMessage = '';

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  
  switch (data.type) {
    case 'message_start':
      console.log('Assistant is typing...');
      currentMessage = '';
      break;
      
    case 'message_delta':
      currentMessage += data.delta.content || '';
      console.log('Received chunk:', data.delta.content);
      break;
      
    case 'message_complete':
      console.log('Complete message:', data.message.content);
      break;
      
    case 'run_update':
      if (data.run.status === 'completed') {
        console.log('Run completed');
        eventSource.close();
      }
      break;
      
    default:
      console.log('Unknown event type:', data.type);
  }
};

eventSource.onerror = (error) => {
  console.error('EventSource error:', error);
  eventSource.close();
};
```
</CodeGroup>

### Handling Tool Calls

<CodeGroup>
```javascript
const runId = 'run_abc123def456';

// Execute the run
const executeResponse = await fetch(`https://api.yourdomain.com/v1/agents/runs/${runId}/execute`, {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    message: "What's the weather in New York?"
  })
});

const executionResult = await executeResponse.json();
const lastMessage = executionResult.messages[executionResult.messages.length - 1];

// Check if the message contains tool calls
if (lastMessage.tool_calls && lastMessage.tool_calls.length > 0) {
  const toolCall = lastMessage.tool_calls[0];
  
  // Handle the tool call based on the tool type
  if (toolCall.tool === 'web_search') {
    // Simulate getting search results
    const searchResults = await performWebSearch(toolCall.parameters.query);
    
    // Send the tool results back to the agent
    const toolResultResponse = await fetch(`https://api.yourdomain.com/v1/agents/runs/${runId}/execute`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        command: {
          type: 'tool_result',
          data: {
            tool_call_id: toolCall.id,
            result: searchResults
          }
        }
      })
    });
    
    const finalResult = await toolResultResponse.json();
    console.log(finalResult.messages[finalResult.messages.length - 1].content);
  }
}

// Helper function to simulate web search
async function performWebSearch(query) {
  // In a real application, this would call your search API
  return JSON.stringify({
    results: [
      {
        title: "Weather in New York",
        snippet: "Currently 72Â°F and sunny in New York City."
      }
    ]
  });
}
```
</CodeGroup>

## Notes and Best Practices

<Tip>
For multi-turn conversations, keep using the same run ID to maintain context throughout the conversation.
</Tip>

<Warning>
Runs have a maximum lifetime of 24 hours. After this period, they will automatically be marked as `completed` and can no longer be executed.
</Warning>

<Info>
When using streaming responses, make sure to properly handle all event types and close the event source when the run is completed.
</Info>

<Check>
Tool calls allow agents to interact with external systems. Make sure to implement proper handling for all tool types your agent might use.
</Check>
