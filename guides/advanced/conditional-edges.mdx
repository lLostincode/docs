---
title: "Conditional Edges"
description: "Implement dynamic routing and control flow in your multi-agent workflows based on agent outputs and state"
---

Conditional edges enable dynamic routing in your agent workflows. Instead of following a fixed path, agents can route to different next steps based on their output, state, or structured data.

## Overview

Conditional edges allow you to:

- **Route based on classification**: Send content to different agents based on categories
- **Implement quality gates**: Retry or revise work that doesn't meet standards
- **Create decision trees**: Branch workflows based on agent decisions
- **Build adaptive systems**: Change behavior based on runtime conditions

<Info>
Conditional edges enable dynamic routing in workflows, allowing agents to make runtime decisions about which path to take next.
</Info>

## How Conditional Edges Work

In a standard workflow, edges are static:

```yaml
edges:
  - from: "agent_a"
    to: "agent_b"  # Always goes to agent_b
```

With conditional edges, the next step is determined at runtime:

```yaml
edges:
  - from: "classifier"
    condition: "Route to the appropriate team based on {{classifier.output.category}}"
    condition_type: "literal"
    possible_outputs: ["tech_support", "billing_support", "general_support"]
```

## Conditional Edge Types

There are two types of conditional edges:

### 1. Boolean Edges

For binary yes/no decisions (quality gates, approvals):

```yaml
edges:
  - from: "agent_name"
    condition: "Your decision prompt with {{agent_name.output.field}}"
    condition_type: "boolean"
    routing:
      yes: "success_agent"
      no: "failure_agent"
```

**Required fields:**
- `condition`: Template string with variable substitution
- `condition_type`: Must be `"boolean"`
- `routing`: Dict with `yes` and `no` keys mapping to agent names

### 2. Literal Edges

For multi-way routing based on specific values:

```yaml
edges:
  - from: "agent_name"
    condition: "Route based on {{agent_name.output.category}}"
    condition_type: "literal"
    possible_outputs: ["agent_a", "agent_b", "agent_c"]
```

**Required fields:**
- `condition`: Template string with variable substitution
- `condition_type`: Must be `"literal"`
- `possible_outputs`: List of valid agent names to route to

## Basic Conditional Routing

### Boolean Routing (Quality Gates)

Route based on true/false conditions:

```yaml
name: "Content Quality Gate"
description: "Review and revise content until it meets quality standards"
architecture: "workflow"

agents:
  - name: "writer"
    agent_type: "llm_agent"
    system_prompt: "Write a blog post on the given topic."
  
  - name: "quality_checker"
    agent_type: "llm_agent"
    
    system_prompt: |
      Review the blog post for quality. Check for:
      - Clear and engaging writing
      - Proper grammar and spelling
      - Logical structure
      - Appropriate length
      
      Determine if it passes quality standards.
    
    structured_output:
      enabled: true
      schema:
        passes_quality:
          type: "bool"
          description: "Whether the content meets quality standards"
        
        issues:
          type: "list[str]"
          description: "List of quality issues found"
        
        suggestions:
          type: "list[str]"
          description: "Suggestions for improvement"
  
  - name: "reviser"
    agent_type: "llm_agent"
    system_prompt: |
      Revise the blog post based on the quality feedback provided.
      Address all issues and implement suggestions.
  
  - name: "publisher"
    agent_type: "llm_agent"
    system_prompt: "Format and publish the approved blog post."

edges:
  - from: "__start__"
    to: "writer"
  
  - from: "writer"
    to: "quality_checker"
  
  # Conditional edge based on quality check
  - from: "quality_checker"
    condition: "Does the content pass quality standards? Check {{quality_checker.output.passes_quality}}"
    condition_type: "boolean"
    routing:
      yes: "publisher"      # If passes_quality = true
      no: "reviser"         # If passes_quality = false
  
  - from: "reviser"
    to: "quality_checker"    # Re-check after revision
  
  - from: "publisher"
    to: "__end__"

entry_point: "writer"
```

### Multi-Way Routing (Classification)

Route to different agents based on categories:

```yaml
name: "Customer Support Router"
description: "Route support tickets to appropriate departments"
architecture: "workflow"

agents:
  - name: "ticket_classifier"
    agent_type: "llm_agent"
    
    system_prompt: |
      Analyze the customer support ticket and classify it into one of these categories:
      - technical: Technical issues, bugs, errors
      - billing: Payment, invoices, subscription questions
      - general: General inquiries, feedback, other
    
    structured_output:
      enabled: true
      schema:
        category:
          type: "str"
          description: "Support ticket category (technical, billing, or general)"
        
        priority:
          type: "str"
          description: "Ticket priority level (low, medium, high, or urgent)"
        
        summary:
          type: "str"
          description: "Brief summary of the issue"
  
  - name: "tech_support"
    agent_type: "react_agent"
    tools: ["knowledge_base_search", "bug_tracker"]
    system_prompt: "Handle technical support issues. Search knowledge base and create bug reports if needed."
  
  - name: "billing_support"
    agent_type: "react_agent"
    tools: ["payment_system", "invoice_generator"]
    system_prompt: "Handle billing and payment inquiries. Access payment history and generate invoices."
  
  - name: "general_support"
    agent_type: "llm_agent"
    system_prompt: "Handle general customer inquiries with friendly, helpful responses."

edges:
  - from: "__start__"
    to: "ticket_classifier"
  
  # Multi-way conditional routing
  - from: "ticket_classifier"
    condition: "Route to the appropriate support team based on {{ticket_classifier.output.category}}"
    condition_type: "literal"
    possible_outputs: ["tech_support", "billing_support", "general_support"]
  
  - from: "tech_support"
    to: "__end__"
  
  - from: "billing_support"
    to: "__end__"
  
  - from: "general_support"
    to: "__end__"

entry_point: "ticket_classifier"
```

## Advanced Patterns

### Content Moderation Pipeline

Implement a multi-stage moderation system:

```yaml
name: "Content Moderation System"
description: "Moderate user-generated content with conditional routing"
architecture: "workflow"

agents:
  - name: "content_analyzer"
    agent_type: "llm_agent"
    
    system_prompt: |
      Analyze user-submitted content for safety and appropriateness.
      
      Classify as:
      - safe: Appropriate content, no issues
      - questionable: Potentially problematic, needs human review
      - unsafe: Clear policy violation
    
    structured_output:
      enabled: true
      schema:
        safety_level:
          type: "str"
          description: "Content safety classification (safe, questionable, or unsafe)"
        
        risk_score:
          type: "float"
          description: "Risk score from 0.0 (safe) to 1.0 (high risk)"
        
        flagged_keywords:
          type: "list[str]"
          description: "Keywords that triggered flags"
        
        violation_types:
          type: "list[str]"
          description: "Types of policy violations detected"
  
  - name: "auto_approver"
    agent_type: "llm_agent"
    system_prompt: "Approve and publish safe content immediately."
  
  - name: "human_review_queue"
    agent_type: "llm_agent"
    system_prompt: |
      Add questionable content to human moderator queue.
      Provide context and flagged issues for review.
  
  - name: "auto_rejector"
    agent_type: "llm_agent"
    system_prompt: |
      Reject unsafe content and generate user notification explaining
      the policy violation and next steps.

edges:
  - from: "__start__"
    to: "content_analyzer"
  
  # Three-way conditional routing
  - from: "content_analyzer"
    condition: "Route based on safety level: {{content_analyzer.output.safety_level}}"
    condition_type: "literal"
    possible_outputs: ["auto_approver", "human_review_queue", "auto_rejector"]
  
  - from: "auto_approver"
    to: "__end__"
  
  - from: "human_review_queue"
    to: "__end__"
  
  - from: "auto_rejector"
    to: "__end__"

entry_point: "content_analyzer"
```

### Iterative Refinement Loop

Create feedback loops for continuous improvement:

```yaml
name: "Code Review System"
description: "Iteratively review and improve code until it passes all checks"
architecture: "workflow"

agents:
  - name: "code_generator"
    agent_type: "react_agent"
    tools: ["code_search", "documentation_lookup"]
    system_prompt: "Generate code based on requirements."
  
  - name: "code_reviewer"
    agent_type: "llm_agent"
    
    system_prompt: |
      Review the generated code for:
      - Correctness and functionality
      - Code quality and best practices
      - Security vulnerabilities
      - Performance issues
      
      Determine if the code is ready for deployment.
    
    structured_output:
      enabled: true
      schema:
        approved:
          type: "bool"
          description: "Whether code is approved for deployment"
        
        issues_found:
          type: "list[str]"
          description: "List of issues that need fixing"
        
        severity:
          type: "str"
          description: "Highest severity of issues found (minor, moderate, or critical)"
        
        review_iteration:
          type: "int"
          description: "Current review iteration number"
  
  - name: "code_improver"
    agent_type: "llm_agent"
    system_prompt: |
      Fix the issues identified in the code review.
      Address all problems while maintaining functionality.
  
  - name: "deployer"
    agent_type: "llm_agent"
    system_prompt: "Prepare approved code for deployment."

edges:
  - from: "__start__"
    to: "code_generator"
  
  - from: "code_generator"
    to: "code_reviewer"
  
  # Conditional: approve or iterate
  - from: "code_reviewer"
    condition: "Is the code approved? Check {{code_reviewer.output.approved}}"
    condition_type: "boolean"
    routing:
      yes: "deployer"
      no: "code_improver"
  
  # Loop back for another review
  - from: "code_improver"
    to: "code_reviewer"
  
  - from: "deployer"
    to: "__end__"

entry_point: "code_generator"
```

## Combining with Structured Output

Conditional edges work best with structured output for reliable routing:

```yaml
agents:
  - name: "decision_maker"
    agent_type: "llm_agent"
    
    structured_output:
      enabled: true
      schema:
        # Use str with clear options for reliable routing
        next_action:
          type: "str"
          description: "Decision on next action (approve, reject, revise, or escalate)"
        
        # Additional context
        confidence:
          type: "float"
          description: "Decision confidence 0.0-1.0"
        
        reasoning:
          type: "str"
          description: "Explanation for the decision"

edges:
  - from: "decision_maker"
    condition: "What action should be taken? {{decision_maker.output.next_action}}"
    condition_type: "literal"
    possible_outputs: ["approval_agent", "rejection_agent", "revision_agent", "escalation_agent"]
```

## Built-in Conditional Logic

### ReAct Agent Iteration Control

ReAct agents have built-in conditional edges for tool calling:

```python
# Internal ReAct agent flow
def should_continue(state):
    if state.iteration >= max_iterations:
        return END
    
    if last_message.tool_calls:
        return "action"  # Execute tools
    
    return END  # Finish
```

Configure iteration limits:

```yaml
agents:
  - name: "research_agent"
    agent_type: "react_agent"
    tools: ["web_search"]
    
    tool_calling:
      max_iterations: 10  # Prevent infinite loops
```

## Best Practices

<Tip>
**Use Structured Output**: Always use structured output with `str` fields for conditional routing. Specify allowed values clearly in descriptions and system prompts to ensure reliable, predictable routing decisions.
</Tip>

<Tip>
**Clear Conditions**: Make routing conditions explicit and mutually exclusive. Avoid ambiguous categories.
</Tip>

<Tip>
**Limit Iterations**: Set maximum iteration counts for loops to prevent infinite cycles.
</Tip>

<Warning>
**Handle All Cases**: Ensure every possible output value has a corresponding route. Missing routes will cause errors.
</Warning>

<Tip>
**Test Edge Cases**: Test your conditional logic with edge cases and unexpected inputs.
</Tip>

## Common Patterns

### Quality Gate Pattern

```
Input → Process → Check Quality → [Pass: Publish | Fail: Revise] → Loop
```

Use for: Content review, code review, data validation

### Classification Router Pattern

```
Input → Classify → [Category A: Agent A | Category B: Agent B | Category C: Agent C]
```

Use for: Support routing, content categorization, task delegation

### Escalation Pattern

```
Input → Attempt → [Success: Complete | Failure: Escalate] → Higher Authority
```

Use for: Error handling, complexity management, human-in-the-loop

### Progressive Refinement Pattern

```
Input → Generate → Evaluate → [Good: Accept | Poor: Improve] → Loop until Good
```

Use for: Iterative improvement, optimization, quality assurance

## Limitations

<Note>
- Conditional edges require the `workflow` architecture
- Maximum routing depth should be reasonable (avoid deeply nested conditions)
- For literal edges: all agent names must be in `possible_outputs`
- For boolean edges: both `yes` and `no` routes must be defined in `routing`
</Note>

## Next Steps

<CardGroup cols={2}>
  <Card title="Structured Output" icon="table" href="/guides/advanced/structured-output">
    Learn how to define schemas for reliable conditional routing
  </Card>
  
  <Card title="YAML Configuration" icon="file-code" href="/guides/yaml-configuration">
    Complete guide to workflow and edge configuration
  </Card>
</CardGroup>
